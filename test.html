<!DOCTYPE html>
<head>
  <title>DPAA Testing Software</title>
  <!-- Font Awesome by Dave Gandy - http://fontawesome.io -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="test_style.css">
</head>

<body>
  <!-- Canvas stack for background grid, drawing, and rendering the figure -->
  <canvas id="gridCanvas"></canvas>
  <canvas id="drawCanvas"></canvas>
  <canvas id="figureCanvas"></canvas>

  <!-- Timer -->
  <div id="timerDiv">
    <p id="timer" style="margin-bottom: 0px; margin-top: 7px;"></p>
  </div>
  <button id="endEarly" onclick="promptSessionEnd()">End</button>

  <div id="sideDiv">
    <!-- Buttons -->
    <button class="ripple" id="resetZoom" onclick="zoomOut(true)"><i class="fa fa-compress"></i></button>

    <!-- Brush/Eraser Toggle -->
    <div id="toggleDiv">
      <button class="toggleButton" id="brush" onclick="setBrush(DRAW_COLOR)"><i class="fa fa-pencil"></i></button>
      <button class="toggleButton" id="eraser" onclick="setBrush(ERASE_COLOR)"><i class="fa fa-eraser"></i></button>
    </div>
  </div>

  <!-- Live score badge (styling lives in test_style.css) -->
  <span id="liveScore">0.0000%</span>

  <script src="gen-config.js"></script>
  <script src="gen-figures.js"></script>
  <script src="test-end.js"></script>
  <script src="test-prompt.js"></script>
  <script src="test-redraw.js"></script>
  <script src="test-touchListener.js"></script>

  <script>
    // ===== Constant Declarations ================================================================
    const PI = Math.PI;
    const TAU = 2 * Math.PI;

    // Toggle live scoring here (JS will hide/show the badge via CSS class)
    const LIVE_SCORING = true;

    var scale = window.devicePixelRatio;
    const W = COMP_TESTING ? window.innerWidth - 90 : screen.height - 90;
    const H = COMP_TESTING ? window.innerHeight : screen.width;

    const GRID_SIZE = W / 6;
    const RENDER_GRID = JSON.parse(localStorage.displayGrid) == "true";

    const ZOOM_SENS = 0.002;
    const MAX_ZOOM = 28; //34

    const SELECTED_FIGURE = figures[parseInt(JSON.parse(localStorage.selectedFigure))];
    const THETA_RESOLUTION_HIGH_LOD = 500;
    const THETA_RESOLUTION_LOW_LOD = 200;

    const IS_TEST = JSON.parse(sessionStorage.isTest) == "true";
    const ENABLE_TIMER = IS_TEST || JSON.parse(localStorage.practiceTimer) == "true";
    const ENABLE_SCORING = IS_TEST || JSON.parse(localStorage.practiceScore) == "true";

    const TEST_TIME_LIMIT_SEC = parseFloat(JSON.parse(localStorage.timerLengthMinutes)) * 60;
    const PRACTICE_TIME_LIMIT_SEC = parseFloat(JSON.parse(localStorage.practiceTimerLengthMinutes)) * 60;
    const TIME_FORMAT = new Intl.NumberFormat('en-US', {
      minimumIntegerDigits: 2 // 05:01 instead of 5:1
    });

    const DRAW_W_FINGER = !IS_TEST && JSON.parse(localStorage.practiceDrawMode) == "finger";
    const ERASE_COLOR = "#FFFFFF";
    const DRAW_COLOR = IS_TEST ? "#808080" : "#808080";

    // DO NOT CHANGE - STANDARDIZES TEST RESULTS
    const AVG_Y = (SELECTED_FIGURE.minY + SELECTED_FIGURE.maxY) / 2;
    const Y_SCALE = (H / 2 - 60) / (SELECTED_FIGURE.maxY - AVG_Y);
    const X_SCALE = (W / 2 - 100) / (SELECTED_FIGURE.width / 2);
    const SCALE = Math.min(X_SCALE, Y_SCALE);

    const SCORE_AREA_SIZE = 4096; // iOS/Safari max safe canvas dimension
    const BRUSH_SIZE = parseInt(JSON.parse(localStorage.brushSize)) / 600 * SCALE;

    // ===== Canvas Setup and Styling =============================================================
    var gridCanvas = document.getElementById('gridCanvas');
    var gridCtx = gridCanvas.getContext("2d", { willReadFrequently: false, aplha: false });

    var drawCanvas = document.getElementById('drawCanvas');
    var drawCtx = drawCanvas.getContext("2d", { willReadFrequently: false, aplha: false });

    var figureCanvas = document.getElementById('figureCanvas');
    var figureCtx = figureCanvas.getContext("2d", { willReadFrequently: false, aplha: false });

    var canvasCol = document.getElementsByTagName("canvas");
    for (let i = 0; i < canvasCol.length; i++) {
      canvasCol[i].style.width = `${W}px`;
      canvasCol[i].style.height = `${H}px`;

      canvasCol[i].width = W * scale;
      canvasCol[i].height = H * scale;
    }

    gridCtx.scale(scale, scale);
    drawCtx.scale(scale, scale);
    figureCtx.scale(scale, scale);

    // Grid color
    gridCtx.strokeStyle = "grey";

    drawCtx.lineCap = "round";
    drawCtx.lineJoin = "round";

    figureCtx.strokeStyle = "black";
    figureCtx.lineCap = "butt";
    figureCtx.lineJoin = "butt";
    figureCtx.lineWidth = 1.9;

    // ===== Variable Declarations ================================================================
    var oldGridSize = GRID_SIZE;

    var offsetX = W / 2;
    var offsetY = H / 2 + 50;
    var zoomX = 0;
    var zoomY = 0;
    var zoom = 1;

    var zoomGestureDist;
    var panX;
    var panY;
    var dynamicGridSize;
    var touchXOffset = 0;

    var timerSeconds = IS_TEST ? TEST_TIME_LIMIT_SEC : PRACTICE_TIME_LIMIT_SEC;

    var currentStroke;
    var lastStrokeX;
    var lastStrokeY;
    var brushColor;

    var activePrompt = null;
    var rightHanded = true;

    var strokes = [];

    function PenStroke(xStart, yStart, strokeColor) {
      this.x = [(xStart - offsetX) / zoom];
      this.y = [(yStart - offsetY) / zoom];
      this.brushSize = BRUSH_SIZE / zoom;
      this.strokeColor = strokeColor;
      lastStrokeX = xStart;
      lastStrokeY = yStart;
    }

    function extendCurrentStroke(rawX, rawY) {
      if (currentStroke == undefined) return;
      currentStroke.x.push((rawX - offsetX) / zoom);
      currentStroke.y.push((rawY - offsetY) / zoom);
      lastStrokeX = rawX;
      lastStrokeY = rawY;

      // Live scoring call on draw
      if (LIVE_SCORING && typeof liveScoreThrottled === "function") {
        const fs = computeFigureScale();
        liveScoreThrottled(fs);
      }
    }

    // ===== Prompts (modals) =====================================================================
    var beginTest = new Prompt("Press play to begin test.<br></br>Timer countdown will begin immediately.", "rgba(240,240,240,1)", [
      new PromptElement("button", "fa fa-caret-right", "green", cancelPrompt)
    ]);
    var endTestEarly = new Prompt("End Test Before Timer Ends?", "rgba(0,0,0,0.3)", [
      new PromptElement("button", "fa fa-check", "green", endTest),
      new PromptElement("button", "fa fa-times", "#6b0000", cancelPrompt)
    ]);
    var endPracticeEarly = new Prompt("End Practice Session?", "rgba(0,0,0,0.3)", [
      new PromptElement("button", "fa fa-check", "green", endTest),
      new PromptElement("button", "fa fa-times", "#6b0000", cancelPrompt)
    ]);
    var timerExpired = new Prompt("Timer Expired.", "rgba(0,0,0,0.3)", [
      new PromptElement("button", "fa fa-arrow-right", "green", endTest),
    ]);
    var loading = new Prompt("Scoring...", "rgba(240,240,240,1)", [
      new PromptElement("progress", "fa fa-arrow-right", "green", endTest),
    ]);
    var handedness = new Prompt("Select your dominant hand:", "rgba(240,240,240,1)", [
      new PromptElement("button", "L", "black", () => { setHandedness("left") }),
      new PromptElement("button", "R", "black", () => { setHandedness("right") })
    ]);

    // ===== Program Initialization ===============================================================
    sessionStorage.isTest = JSON.stringify("false"); // Clear any previously set isTest flag

    mainRedraw();           // Draw main content
    activatePrompt(handedness); // Call handedness prompt

    if (ENABLE_TIMER) {
      document.getElementById("timerDiv").style.display = "block";
      updateTimer();
      setInterval(decrementTimer, 1000);
    }

    // ===== Main redraw ==========================================================================
    function mainRedraw() {
      // Calculate screen offsets for zooming and panning
      dynamicGridSize = GRID_SIZE * zoom;
      let gridDelta = dynamicGridSize - oldGridSize;
      offsetX -= gridDelta * (zoomX - offsetX) / oldGridSize;
      offsetY -= gridDelta * (zoomY - offsetY) / oldGridSize;
      oldGridSize = dynamicGridSize;

      // Limit panning
      offsetX = clamp(offsetX, W - W * 0.53 * zoom, W * 0.53 * zoom);
      offsetY = clamp(offsetY, H - H * 0.53 * zoom, H * 0.53 * zoom);

      // Redraw layers
      gridCtxRedraw();
      drawCtxRedraw();
      figureCtxRedraw();
    }

    // ===== Brush/Eraser Toggle ==================================================================
    function setBrush(color) {
      brushColor = color;

      let active = document.getElementById("brush");
      let inactive = document.getElementById("eraser");
      if (color == ERASE_COLOR) {
        active = document.getElementById("eraser");
        inactive = document.getElementById("brush");
      }

      active.style.outline = "2px solid black";
      inactive.style.outline = "4px outset black";

      active.style.backgroundColor = "#bdbbbb";
      inactive.style.backgroundColor = "#FFFFFF";
    }
    setBrush(DRAW_COLOR); // Initialize to brush instead of eraser

    // ===== Handedness ===========================================================================
    function setHandedness(hand) {
      if (hand == "right") {
        // Handle all the canvases
        for (let i = 0; i < canvasCol.length; i++) {
          canvasCol[i].style.left = "90px";
        }

        // Sidebar UI
        document.getElementById("sideDiv").style.left = "0px";
        document.getElementById("sideDiv").style.right = "auto";

        // Timer and End Test Buttons
        document.body.style.flexDirection = "row-reverse";
        document.getElementById("timerDiv").style.marginLeft = "0px";
        document.getElementById("timerDiv").style.marginRight = "90px";
        document.getElementById("endEarly").style.marginLeft = "100px";
        document.getElementById("endEarly").style.marginRight = "10px";

        // Touch offset
        touchXOffset = 90;
      }

      activatePrompt(beginTest);
    }

    // ===== Drawing helpers ======================================================================
    function circle(x, y, r, fill, ctx) {
      ctx.beginPath();
      ctx.arc(x, y, r, 0, TAU, false);
      if (fill) { ctx.fill(); } else { ctx.stroke(); }
    }
    function line(x, y, x2, y2, width, ctx) {
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    // ===== Math utils ===========================================================================
    function clamp(x, min, max) { return Math.max(Math.min(x, max), min); }
    function lerp(a, b, alpha) { return a + clamp(alpha, 0, 1) * (b - a); }

    // ===== Timer handling =======================================================================
    function updateTimer() {
      let mins = TIME_FORMAT.format("" + Math.floor(timerSeconds / 60));
      let secs = TIME_FORMAT.format("" + timerSeconds % 60);
      document.getElementById("timer").textContent = mins + ":" + secs;
    }
    function decrementTimer() {
      if (activePrompt) return;
      if (timerSeconds > 0) {
        timerSeconds--;
        updateTimer();
      } else {
        activatePrompt(timerExpired);
      }
    }

    // ===== Zoom handling ========================================================================
    function zoomOut(animate) {
      offsetX = W / 2;
      offsetY = H / 2 + 50;
      zoomX = offsetX;
      zoomY = offsetY;
      zoom = 1;
      oldGridSize = GRID_SIZE;
      mainRedraw();

      if (animate) zoomOutAnimation(0);
    }

    function zoomOutAnimation(inc) {
      zoom -= 0.005 * Math.sign(10 - inc);
      zoomX = offsetX;
      zoomY = H / 2 - offsetY;
      mainRedraw();

      if (inc < 20) requestAnimationFrame(() => { zoomOutAnimation(inc + 1) });
    }

    // ===== Boot the live badge once so it's never blank =========================================
    (function bootLiveBadge() {
      const el = document.getElementById('liveScore');
      if (!el) return;
      if (!LIVE_SCORING) el.classList.add('hidden'); // CSS hides it when off
      // Force one initial live update if the helper exists
      if (LIVE_SCORING && typeof computeFigureScale === "function" && typeof liveScoreThrottled === "function") {
        liveScoreThrottled._last = 0; // reset throttle window
        liveScoreThrottled(computeFigureScale(), { force: true });
      }
    })();
  </script>
</body>
</html>
